<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Low-Level Software Security for Compiler Developers</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="default.css" />
  
</head>
<body>
<header id="title-block-header">
<h1 class="title">Low-Level Software Security for Compiler Developers</h1>

<p>
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
  <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />
  This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</p>
<p>
  © 2021 Arm Limited <a href="mailto:kristof.beyls@arm.com" class="email">kristof.beyls@arm.com</a><br />
</p>

</header>
<nav id="TOC">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
<li><a href="#how-this-book-is-created"><span class="toc-section-number">1.1</span> How this book is created</a></li>
</ul></li>
<li><a href="#memory-vulnerability-based-attacks-and-mitigations"><span class="toc-section-number">2</span> Memory vulnerability based attacks and mitigations</a><ul>
<li><a href="#a-bit-of-background-on-memory-vulnerabilities"><span class="toc-section-number">2.1</span> A bit of background on memory vulnerabilities</a></li>
<li><a href="#exploitation-primitives"><span class="toc-section-number">2.2</span> Exploitation primitives</a></li>
<li><a href="#stack-overflows"><span class="toc-section-number">2.3</span> Stack overflows</a></li>
<li><a href="#code-reuse-attacks"><span class="toc-section-number">2.4</span> Code reuse attacks</a></li>
<li><a href="#non-control-data-exploits"><span class="toc-section-number">2.5</span> Non-control data exploits</a></li>
<li><a href="#hardware-support-for-protection-against-memory-vulnerabilities"><span class="toc-section-number">2.6</span> Hardware support for protection against memory vulnerabilities</a></li>
<li><a href="#other-issues"><span class="toc-section-number">2.7</span> Other issues</a></li>
<li><a href="#jit-compiler-vulnerabilities"><span class="toc-section-number">2.8</span> JIT compiler vulnerabilities</a></li>
</ul></li>
<li><a href="#physical-access-side-channel-attacks"><span class="toc-section-number">3</span> Physical access side-channel attacks</a></li>
<li><a href="#remote-access-side-channel-attacks"><span class="toc-section-number">4</span> Remote access side-channel attacks</a><ul>
<li><a href="#timing-attacks"><span class="toc-section-number">4.1</span> Timing attacks</a></li>
<li><a href="#cache-side-channel-attacks"><span class="toc-section-number">4.2</span> Cache side-channel attacks</a></li>
</ul></li>
<li><a href="#other-security-topics-relevant-for-compiler-developers"><span class="toc-section-number">5</span> Other security topics relevant for compiler developers</a></li>
<li><a href="#appendix-contribution-guidelines">Appendix: contribution guidelines</a></li>
<li><a href="#references">References</a></li>
</ul>
</nav>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>Compilers, assemblers and similar tools generate all the binary code that processors execute. It is no surprise then that for security analysis and hardening relevant for binary code, these tools have a major role to play. Often the only practical way to protect all binaries with a particular security hardening method is to let the compiler adapt its automatic code generation.</p>
<p>With software security becoming even more important in recent years, it is no surprise to see an ever increasing variety of security hardening features and mitigations against vulnerabilities implemented in compilers.</p>
<p>Indeed, compared to a few decades ago, today’s compiler developer is much more likely to work on security features, at least some of their time.</p>
<p>Furthermore, with the ever-expanding range of techniques implemented, it has become very hard to gain a basic understanding of all security features implemented in typical compilers.</p>
<p>This poses a practical problem: compiler developers must be able to work on security hardening features, yet it is hard to gain a good basic understanding of such compiler features.</p>
<p>This book aims to help developers of code generation tools such as JITs, compilers, linkers and assemblers to overcome this.</p>
<p>There is a lot of material that can be found explaining individual vulnerabilities or attack vectors. There are also lots of presentations explaining specific exploits. But there seems to be a limited set of material that gives a structured overview of all vulnerabilities and exploits for which a code generator could play a role in protecting against them.</p>
<p>This book aims to provide such a structured, broad overview. It does not necessarily go into full details. Instead it aims to give a thorough description of all relevant high-level aspects of attacks, vulnerabilities, mitigations and hardening techniques. For further details, this book provides pointers to material with more details on specific techniques.</p>
<p>The purpose of this book is to serve as a guide to every compiler developer that needs to learn about software security relevant to compilers. Even though the focus is on compiler developers, we expect that this book will also be useful to other people working on low-level software.</p>
<h2 id="how-this-book-is-created"><span class="header-section-number">1.1</span> How this book is created</h2>
<p>The idea for this book emerged out of a frustration of not finding a good overview on this topic. Kristof Beyls and Georgia Kouveli, both compiler engineers working on security features, wished a book like this would exist. After not finding such a book, they decided to try and write one themselves. They immediately realized that they do not have all necessary expertise themselves to complete such a daunting task. So they decided to try and create this book in an open source style, seeking contributions from many experts.</p>
<p>As you read this, the book remains unfinished. This book may well never be finished, as new vulnerabilities continue to be discovered regularly. Our hope is that developing the book as an open source project will allow for it to continue to evolve and improve. The open source development process of this book increases the likelihood that it remains relevant as new vulnerabilities and mitigations emerge.</p>
<p>Kristof and Georgia, the initial authors, are far from experts on all possible vulnerabilities. So what is the plan to get high quality content to cover all relevant topics? It is two-fold.</p>
<p>First, by studying specific topics, they hope to gain enough knowledge to write up a good summary for this book.</p>
<p>Second, they very much invite and welcome contributions. If you’re interested in potentially contributing content, please go to the home location for the open source project at <a href="https://github.com/llsoftsec/llsoftsecbook" class="uri">https://github.com/llsoftsec/llsoftsecbook</a>.</p>
<p>As a reader, you can also contribute to making this book better. We highly encourage feedback, both positive and constructive criticisms. We prefer feedback to be received through <a href="https://github.com/llsoftsec/llsoftsecbook" class="uri">https://github.com/llsoftsec/llsoftsecbook</a>.</p>

<h1 id="memory-vulnerability-based-attacks-and-mitigations"><span class="header-section-number">2</span> Memory vulnerability based attacks and mitigations</h1>
<h2 id="a-bit-of-background-on-memory-vulnerabilities"><span class="header-section-number">2.1</span> A bit of background on memory vulnerabilities</h2>
<p>Memory access errors describe memory accesses that, although permitted by a program, were not intended by the programmer. These types of errors are usually defined <span class="citation" data-cites="Hicks2014">(Hicks <a href="#ref-Hicks2014">2014</a>)</span> by explicitly listing their types, which include:</p>
<ul>
<li>buffer overflow</li>
<li>null pointer dereference</li>
<li>use after free</li>
<li>use of uninitialized memory</li>
<li>illegal free</li>
</ul>
<p>Memory vulnerabilities are an important class of vulnerabilities that arise due to these types of errors, and they most commonly occur due to programming mistakes when using languages such as C/C++. These languages do not provide mechanisms to protect against memory access errors by default. An attacker can exploit such vulnerabilities to leak sensitive data or overwrite critical memory locations and gain control of the vulnerable program.</p>
<p>Memory vulnerabilities have a long history. The <a href="https://en.wikipedia.org/wiki/Morris_worm">Morris worm</a> in 1988 was the first widely publicized attack exploiting a buffer overflow. Later, in the mid-90s, a few famous write-ups describing buffer overflows appeared <span class="citation" data-cites="AlephOne1996">(Aleph One <a href="#ref-AlephOne1996">1996</a>)</span>. <a href="#stack-overflows">Stack overflows</a> were mitigated with <a href="#stack-overflows">stack canaries</a> and <a href="#stack-overflows">non-executable stacks</a>. The answer was more ingenious ways to bypass these mitigations: <a href="#code-reuse-attacks">code reuse attacks</a>, starting with attacks like <a href="#code-reuse-attacks">return-into-libc</a> <span class="citation" data-cites="Solar1997">(Solar Designer <a href="#ref-Solar1997">1997</a>)</span>. Code reuse attacks later evolved to <a href="#code-reuse-attacks">Return-Oriented Programming (ROP)</a> <span class="citation" data-cites="Shacham2007">(Shacham <a href="#ref-Shacham2007">2007</a>)</span> and even more complex techniques.</p>
<p>To defend against code reuse attacks, the <a href="#code-reuse-attacks">Address Space Layout Randomization (ASLR)</a> and <a href="#code-reuse-attacks">Control-Flow Integrity (CFI)</a> measures were introduced.  This interaction between offensive and defensive security research has been essential to improving security, and continues to this day. Each newly deployed mitigation results in attempts, often successful, to bypass it, or in alternative, more complex exploitation techniques, and even tools to automate them.</p>
<p>Memory safe <span class="citation" data-cites="Hicks2014">(Hicks <a href="#ref-Hicks2014">2014</a>)</span> languages are designed with prevention of such vulnerabilities in mind and use techniques such as bounds checking and automatic memory management. If these languages promise to eliminate memory vulnerabilities, why are we still discussing this topic?</p>
<p>On the one hand, C and C++ remain very popular languages, particular in the implementation of low-level software. On the other hand, programs written in memory safe languages can themselves be vulnerable to memory errors as a result of bugs in how they are implemented, e.g. a bug in their compiler. Can we fix the problem by also using memory safe languages for the compiler and runtime implementation? Even if that were as simple as it sounds, unfortunately there are types of programming errors that these languages cannot protect against. For example, a logical error in the implementation of a compiler or runtime for a memory safe language can lead to a memory access error not being detected. We will see examples of such logic errors in compiler optimizations in a <a href="#jit-compiler-vulnerabilities">later section</a>.</p>
<p>Given the rich history of memory vulnerabilities and mitigations and the active developments in this area, compiler developers are likely to encounter some of these issues over the course of their careers. This chapter aims to serve as an introduction to this area. We start with a discussion of exploitation primitives, which can be useful when discussing threat models . We then continue with a more detailed discussion of the various types of vulnerabilities, along with their mitigations, presented in a rough chronological order of their appearance, and, therefore, complexity.</p>
<h2 id="exploitation-primitives"><span class="header-section-number">2.2</span> Exploitation primitives</h2>

<h2 id="stack-overflows"><span class="header-section-number">2.3</span> Stack overflows</h2>

<h2 id="code-reuse-attacks"><span class="header-section-number">2.4</span> Code reuse attacks</h2>

<h2 id="non-control-data-exploits"><span class="header-section-number">2.5</span> Non-control data exploits</h2>

<h2 id="hardware-support-for-protection-against-memory-vulnerabilities"><span class="header-section-number">2.6</span> Hardware support for protection against memory vulnerabilities</h2>

<h2 id="other-issues"><span class="header-section-number">2.7</span> Other issues</h2>

<h2 id="jit-compiler-vulnerabilities"><span class="header-section-number">2.8</span> JIT compiler vulnerabilities</h2>

<h1 id="physical-access-side-channel-attacks"><span class="header-section-number">3</span> Physical access side-channel attacks</h1>

<h1 id="remote-access-side-channel-attacks"><span class="header-section-number">4</span> Remote access side-channel attacks</h1>
<p>This chapter covers side-channel attacks for which the attacker does not need physical access to the hardware.</p>
<h2 id="timing-attacks"><span class="header-section-number">4.1</span> Timing attacks</h2>
<p>An implementation of a cryptographic algorithm can leak information about the data it processes if its run time is influenced by the value of the processed data. Attacks making use of this are called timing attacks.</p>
<p>The main mitigation against such attacks consists of carefully implementing the algorithm such that the execution time remains independent of the processed data. This can be done by making sure that both:</p>
<ol type="a">
<li><p>The control flow, i.e. the trace of instructions executed, does not change depending on the processed data. This guarantees that every time the algorithm runs, exactly the same sequence of instructions is executed, independent of the processed data.</p></li>
<li><p>The instructions used to implement the algorithm are from the subset of instructions for which the execution time is known to not depend on the data values it processes.</p>
<p>For example, in the Arm architecture, the Armv8.4-A <a href="https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/DIT--Data-Independent-Timing">DIT extension</a> guarantees that execution time is data-independent for a subset of the AArch64 instructions.</p>
<p>By ensuring that the extension is enabled and only instructions in the subset are used, data-independent execution time is guaranteed.</p></li>
</ol>
<p>At the moment, we do not know of a compiler implementation that actively helps to guarantee both (a) and (b). A great reference giving practical advice on how to achieve (a), (b) and more security hardening properties specific for cryptographic kernels is found in <span class="citation" data-cites="Pornin2018">(Pornin <a href="#ref-Pornin2018">2018</a>)</span>.</p>
<p>As discussed in <span class="citation" data-cites="Pornin2018">(Pornin <a href="#ref-Pornin2018">2018</a>)</span>, when implementing cryptographic algorithms, you also need to keep cache side-channel attacks in mind, which are discussed in the <a href="#cache-side-channel-attacks">section on cache side-channel attacks</a>.</p>
<h2 id="cache-side-channel-attacks"><span class="header-section-number">4.2</span> Cache side-channel attacks</h2>
<!-- markdown-link-check-disable -->

<!-- markdown-link-check-enable-->
<h1 id="other-security-topics-relevant-for-compiler-developers"><span class="header-section-number">5</span> Other security topics relevant for compiler developers</h1>


<h1 id="appendix-contribution-guidelines" class="unnumbered">Appendix: contribution guidelines</h1>



<h1 id="references" class="unnumbered">References</h1>
<div id="refs">
<div id="ref-AlephOne1996">
<p>Aleph One. 1996. “Smashing the Stack for Fun and Profit.” 1996. <a href="http://www.phrack.org/issues/49/14.html#article">http://www.phrack.org/issues/49/14.html#article</a>.</p>
</div>
<div id="ref-Hicks2014">
<p>Hicks, Michael. 2014. “What Is Memory Safety?” 2014. <a href="http://www.pl-enthusiast.net/2014/07/21/memory-safety/">http://www.pl-enthusiast.net/2014/07/21/memory-safety/</a>.</p>
</div>
<div id="ref-Pornin2018">
<p>Pornin, Thomas. 2018. “Why Constant-Time Crypto?” 2018. <a href="https://www.bearssl.org/constanttime.html">https://www.bearssl.org/constanttime.html</a>.</p>
</div>
<div id="ref-Shacham2007">
<p>Shacham, Hovav. 2007. “The Geometry of Innocent Flesh on the Bone: Return-into-Libc Without Function Calls (on the X86).” In <em>Proceedings of the 14th Acm Conference on Computer and Communications Security</em>, 552–61. CCS ’07. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/1315245.1315313">https://doi.org/10.1145/1315245.1315313</a>.</p>
</div>
<div id="ref-Solar1997">
<p>Solar Designer. 1997. “Getting Around Non-Executable Stack (and Fix).” 1997. <a href="https://seclists.org/bugtraq/1997/Aug/63">https://seclists.org/bugtraq/1997/Aug/63</a>.</p>
</div>
</div>
</body>
</html>
